[
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "Difference between process.nextTick and setImmediate",
    "answer": "**process.nextTick() vs setImmediate() in Node.js:**\n\n**process.nextTick():**\n- **Execution timing**: Immediately after current operation completes\n- **Priority**: Highest priority in event loop\n- **Queue**: Runs before I/O events, timers, and setImmediate\n- **Risk**: Can cause I/O starvation if overused\n- **Use case**: Critical operations that must run before anything else\n\n**setImmediate():**\n- **Execution timing**: After current event loop phase completes\n- **Priority**: Lower priority than process.nextTick\n- **Queue**: Runs after I/O events in the check phase\n- **Risk**: Less likely to cause starvation\n- **Use case**: Operations that should run after I/O events\n\n**Execution Order:**\n```javascript\nconsole.log('Start');\n\nsetImmediate(() => console.log('setImmediate'));\nprocess.nextTick(() => console.log('nextTick'));\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// nextTick\n// setImmediate\n```\n\n**Event Loop Phases:**\n1. **Timer phase**: setTimeout, setInterval\n2. **I/O callbacks**: Most callbacks\n3. **Idle, prepare**: Internal use\n4. **Poll phase**: Fetch new I/O events\n5. **Check phase**: setImmediate callbacks\n6. **Close callbacks**: Socket close events\n\n**process.nextTick runs between each phase**\n\n**Best Practices:**\n- Use `process.nextTick()` sparingly for urgent tasks\n- Prefer `setImmediate()` for general async operations\n- Avoid recursive `process.nextTick()` calls\n- Consider `setImmediate()` for better I/O performance"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "How would you debounce a function in JavaScript?",
    "answer": "**Debouncing in JavaScript:**\n\n**Definition:**\n- Technique to limit function execution frequency\n- Delays function execution until after a pause in calls\n- Executes only once after the specified delay period\n- Useful for performance optimization\n\n**Implementation:**\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    // Clear previous timeout\n    clearTimeout(timeoutId);\n    \n    // Set new timeout\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\n// Usage example\nconst searchHandler = debounce((query) => {\n  console.log('Searching for:', query);\n  // API call here\n}, 300);\n\n// This will only execute once, 300ms after the last call\nsearchHandler('a');\nsearchHandler('ab');\nsearchHandler('abc'); // Only this will execute\n```\n\n**Advanced Implementation with Immediate Execution:**\n```javascript\nfunction debounce(func, delay, immediate = false) {\n  let timeoutId;\n  \n  return function(...args) {\n    const callNow = immediate && !timeoutId;\n    \n    clearTimeout(timeoutId);\n    \n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      if (!immediate) func.apply(this, args);\n    }, delay);\n    \n    if (callNow) func.apply(this, args);\n  };\n}\n```\n\n**Use Cases:**\n- **Search input**: Delay API calls until user stops typing\n- **Window resize**: Limit resize event handlers\n- **Scroll events**: Reduce scroll event frequency\n- **Button clicks**: Prevent rapid multiple submissions\n- **Form validation**: Delay validation until user pauses\n\n**Benefits:**\n- Reduces unnecessary function calls\n- Improves performance\n- Prevents API spam\n- Better user experience\n- Reduces server load"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What are closures in JavaScript?",
    "answer": "**Closures in JavaScript:**\n\n**Definition:**\n- A function that has access to variables in its outer (enclosing) scope even after the outer function has returned\n- Combination of a function and the lexical environment in which it was declared\n- Preserves data privacy and state between function calls\n\n**Key Features:**\n\n**1. Scope Access:**\n- Inner function can access outer function's variables\n- Variables remain in memory even after outer function completes\n- Creates private variables that can't be accessed directly\n\n**2. Data Persistence:**\n- Maintains state between function calls\n- Each closure instance has its own copy of variables\n- Variables persist as long as the closure exists\n\n**Basic Example:**\n```javascript\nfunction createCounter() {\n  let count = 0; // Private variable\n  \n  return function() {\n    count++; // Access to outer scope\n    return count;\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log(counter1()); // 1\nconsole.log(counter1()); // 2\nconsole.log(counter2()); // 1 (separate instance)\n```\n\n**Advanced Example - Module Pattern:**\n```javascript\nfunction createCalculator() {\n  let result = 0;\n  \n  return {\n    add: function(x) {\n      result += x;\n      return this;\n    },\n    multiply: function(x) {\n      result *= x;\n      return this;\n    },\n    getResult: function() {\n      return result;\n    },\n    reset: function() {\n      result = 0;\n      return this;\n    }\n  };\n}\n\nconst calc = createCalculator();\ncalc.add(5).multiply(2).add(3);\nconsole.log(calc.getResult()); // 13\n```\n\n**Use Cases:**\n- **Data privacy**: Creating private variables\n- **Function factories**: Creating specialized functions\n- **Event handlers**: Maintaining state in callbacks\n- **Module patterns**: Encapsulating functionality\n- **Currying**: Creating partially applied functions\n- **Memoization**: Caching function results\n\n**Benefits:**\n- Data encapsulation and privacy\n- State persistence\n- Avoiding global variables\n- Creating reusable, configurable functions"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What are closures in JavaScript?",
    "answer": "Closures in JavaScript:\n\nDefinition:\n- Function with access to outer scope\n- Maintains state between executions\n- Preserves data privacy\n\nKey Features:\n1. Scope Access:\n- Inner function accesses outer variables\n- Variables remain in memory\n- Private variable creation\n\n2. Use Cases:\n- Data privacy\n- Function factories\n- Event handlers\n- Module patterns\n\nExample:\n```javascript\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n```"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What are JavaScript generators?",
    "answer": "**JavaScript Generators:**\n\n**Definition:**\n- Special functions that can pause and resume execution\n- Return multiple values over time using `yield` keyword\n- Use `function*` syntax to declare\n- Return an iterator object when called\n\n**Key Features:**\n\n**1. Pause and Resume:**\n- Can pause execution at any `yield` point\n- Maintain state between yields\n- Resume execution from where it left off\n- Control flow externally via `.next()` method\n\n**2. Lazy Evaluation:**\n- Values are generated on-demand\n- Memory efficient for large sequences\n- Can represent infinite sequences\n\n**Basic Example:**\n```javascript\nfunction* numberGenerator() {\n  console.log('Starting generator');\n  yield 1;\n  console.log('After first yield');\n  yield 2;\n  console.log('After second yield');\n  yield 3;\n  console.log('Generator finished');\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n**Advanced Example - Infinite Sequence:**\n```javascript\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nconsole.log(fib.next().value); // 0\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 2\n```\n\n  "
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is a polyfill?",
    "answer": "**JavaScript Polyfills:**\n\n**Definition:**\n- Code that implements modern features in older browsers\n- Provides backward compatibility for newer JavaScript features\n- \"Fills the gaps\" in browser support\n- Allows you to use modern APIs in legacy environments\n\n**Key Characteristics:**\n- **Backward compatibility**: Makes new features work in old browsers\n- **Feature detection**: Checks if feature exists before adding polyfill\n- **Graceful degradation**: Provides fallback functionality\n- **Conditional loading**: Only loads when needed\n\n**Common Use Cases:**\n- Array methods (`map`, `filter`, `reduce`, `find`)\n- Promise implementation for older browsers\n- Object methods (`Object.assign`, `Object.keys`)\n- String methods (`includes`, `startsWith`, `endsWith`)\n- ES6+ features in older environments\n\n**Example:**\n```javascript\n// Polyfill for Array.includes()\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement) {\n    return this.indexOf(searchElement) !== -1;\n  };\n}\n```\n\n**Best Practices:**\n- Check browser support before applying polyfill\n- Use feature detection rather than browser detection\n- Load polyfills conditionally to reduce bundle size\n- Keep polyfills updated\n- Consider using services like Polyfill.io for automatic polyfill serving"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is Hoisting?",
    "answer": "**JavaScript Hoisting:**\n\n**Definition:**\n- Behavior where variable and function declarations are moved to the top of their scope\n- Occurs during the memory creation phase of execution context\n- Allows using variables and functions before their declaration in code\n\n**Types of Hoisting:**\n\n**1. Variable Hoisting:**\n- **var**: Declarations are hoisted, initialized with `undefined`\n- **let/const**: Hoisted but not initialized (Temporal Dead Zone)\n- **Assignments**: Not hoisted, only declarations\n\n**2. Function Hoisting:**\n- **Function declarations**: Fully hoisted (can be called before declaration)\n- **Function expressions**: Not hoisted\n- **Arrow functions**: Not hoisted\n\n**Examples:**\n```javascript\n// This works due to hoisting\nconsole.log(x); // undefined (not error)\nvar x = 5;\n\n// This throws ReferenceError\nconsole.log(y); // ReferenceError\nlet y = 10;\n\n// Function declaration - works\nsayHello(); // \"Hello!\"\nfunction sayHello() {\n  console.log(\"Hello!\");\n}\n\n// Function expression - doesn't work\nsayGoodbye(); // TypeError\nvar sayGoodbye = function() {\n  console.log(\"Goodbye!\");\n};\n```\n\n**Key Points:**\n- Only declarations are hoisted, not initializations\n- Temporal Dead Zone exists for `let` and `const`\n- Best practice: declare variables and functions before using them"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between call, apply and bind?",
    "answer": "**Function Methods for Context Binding:**\n\n**1. call():**\n- Invokes function immediately\n- Takes arguments separately\n- Sets 'this' context\n- Syntax: `func.call(thisArg, arg1, arg2, ...)`\n\n**2. apply():**\n- Invokes function immediately\n- Takes arguments as array\n- Sets 'this' context\n- Syntax: `func.apply(thisArg, [arg1, arg2, ...])`\n\n**3. bind():**\n- Returns new function\n- Preserves 'this' context\n- Can be called later\n- Syntax: `func.bind(thisArg, arg1, arg2, ...)`\n\n**Example:**\n```javascript\nconst person = { name: 'John' };\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\n\ngreet.call(person, 'Hello', '!');\ngreet.apply(person, ['Hello', '!']);\nconst boundGreet = greet.bind(person, 'Hello');\nboundGreet('!'); // Can be called later\n```"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between function declaration and function expression?",
    "answer": "**Function Declaration vs Expression:**\n\n**Function Declaration:**\n- **Hoisting**: Fully hoisted to top of scope\n- **Calling**: Can be called before declaration\n- **Syntax**: Starts with 'function' keyword\n- **Naming**: Must have a name\n- **Example**: `function greet() { return 'Hello'; }`\n\n**Function Expression:**\n- **Hoisting**: Not hoisted (variable is hoisted, but not the function)\n- **Calling**: Must be defined before use\n- **Syntax**: Function assigned to variable\n- **Naming**: Can be anonymous or named\n- **Example**: `const greet = function() { return 'Hello'; };`\n\n**Arrow Function Expression:**\n- **Syntax**: `const greet = () => 'Hello';`\n- **this binding**: Lexical this binding\n- **Hoisting**: Not hoisted\n\n**Best Practices:**\n- Use declarations for main functions that need hoisting\n- Use expressions for callbacks and when you want to control when the function is created\n- Consider hoisting behavior in your code structure"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between let and const?",
    "answer": "**let vs const:**\n\n**let:**\n- **Scope**: Block-scoped\n- **Reassignment**: Can be reassigned\n- **Redeclaration**: Cannot be redeclared in same scope\n- **Hoisting**: Hoisted but in Temporal Dead Zone\n- **Initialization**: Can be declared without initialization\n\n**const:**\n- **Scope**: Block-scoped\n- **Reassignment**: Cannot be reassigned\n- **Redeclaration**: Cannot be redeclared in same scope\n- **Hoisting**: Hoisted but in Temporal Dead Zone\n- **Initialization**: Must be initialized at declaration\n\n**Key Differences:**\n- `const` prevents reassignment of the variable reference\n- For objects/arrays, `const` allows mutation of contents\n- Both have block scope (unlike `var`)\n- Both prevent redeclaration\n\n**Best Practices:**\n- Use `const` by default\n- Use `let` when reassignment is needed\n- Avoid `var` completely in modern JavaScript"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between map, filter and reduce?",
    "answer": "**Array Methods:**\n\n**1. map():**\n- **Purpose**: Transforms each element\n- **Returns**: New array with same length\n- **Use case**: Data transformation\n- **Example**: Convert numbers to strings\n\n**2. filter():**\n- **Purpose**: Selects elements based on condition\n- **Returns**: New array with length â‰¤ original\n- **Use case**: Data filtering\n- **Example**: Get even numbers from array\n\n**3. reduce():**\n- **Purpose**: Accumulates values into single result\n- **Returns**: Single value (any type)\n- **Use case**: Data aggregation\n- **Example**: Sum all numbers in array\n\n**Example:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Transform each number (multiply by 2)\nconst doubled = numbers.map(x => x * 2); // [2, 4, 6, 8, 10]\n\n// Filter even numbers\nconst even = numbers.filter(x => x % 2 === 0); // [2, 4]\n\n// Reduce to sum\nconst sum = numbers.reduce((acc, curr) => acc + curr, 0); // 15\n```"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between null and undefined?",
    "answer": "**null vs undefined:**\n\n**undefined:**\n- Variable declared but not assigned\n- Function parameter not provided\n- Object property doesn't exist\n- Type is 'undefined'\n- Default value for uninitialized variables\n\n**null:**\n- Explicitly assigned value\n- Represents intentional absence of value\n- Type is 'object' (this is a known JavaScript quirk)\n- Must be assigned deliberately\n\n**Key Differences:**\n- `null` is intentional, `undefined` is default\n- Different types when checked with `typeof`\n- Both are falsy values\n- Use `===` for precise comparison\n\n**Best Practices:**\n- Use `null` for intentional absence\n- Check for both in conditional statements"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between setTimeout and setInterval?",
    "answer": "**Timing Functions:**\n\n**setTimeout():**\n- **Execution**: Runs once after specified delay\n- **Purpose**: One-time delayed execution\n- **Returns**: Timeout ID for cancellation\n- **Clearing**: Use `clearTimeout(id)`\n\n**setInterval():**\n- **Execution**: Runs repeatedly at specified intervals\n- **Purpose**: Repeated execution\n- **Returns**: Interval ID for cancellation\n- **Clearing**: Use `clearInterval(id)`\n\n**Example:**\n```javascript\n// One-time execution after 1 second\nconst timeoutId = setTimeout(() => {\n  console.log('This runs once after 1 second');\n}, 1000);\n\n// Repeated execution every 1 second\nconst intervalId = setInterval(() => {\n  console.log('This runs every second');\n}, 1000);\n\n// Clear timers\nclearTimeout(timeoutId);\nclearInterval(intervalId);\n```\n\n**Best Practices:**\n- Always clear intervals when no longer needed\n- Use setTimeout for one-time delayed actions\n- Use setInterval for periodic tasks\n- Consider performance impact of frequent intervals\n- Be aware that intervals may not run exactly on time due to JavaScript's single-threaded nature"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is the difference between synchronous and asynchronous code?",
    "answer": "**Synchronous vs Asynchronous Code:**\n\n**Synchronous Code:**\n- **Execution**: Line by line, sequential\n- **Blocking**: Blocks until completion\n- **Flow**: Predictable, linear flow\n- **Understanding**: Simpler to understand and debug\n- **Performance**: Can be slower for I/O operations\n\n**Asynchronous Code:**\n- **Execution**: Non-blocking, parallel\n- **Blocking**: Continues while waiting for operations\n- **Flow**: Uses callbacks, promises, async/await\n- **Understanding**: More complex but better performance\n- **Performance**: Better for I/O operations\n\n**Key Differences:**\n- **Execution order**: Sync is predictable, async can vary\n- **Blocking behavior**: Sync blocks, async doesn't\n- **Error handling**: Different patterns needed\n- **Code complexity**: Async requires more careful handling\n\n**Use Cases:**\n- **Synchronous**: Simple calculations, file system operations in scripts\n- **Asynchronous**: Network requests, user interactions, timers, database operations"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "What is type coercion in JavaScript?",
    "answer": "**JavaScript Type Coercion:**\n\n**Definition:**\n- Automatic or explicit conversion between different data types\n- Occurs during operations when types don't match\n- Can be predictable or unpredictable depending on the operation\n\n**Types of Coercion:**\n\n**1. Implicit Coercion (Automatic):**\n- JavaScript automatically converts types\n- Happens during operations like `+`, `==`, conditionals\n- Can be unpredictable and cause bugs\n\n**2. Explicit Coercion (Manual):**\n- Developer manually converts types\n- Using functions like `String()`, `Number()`, `Boolean()`\n- More predictable and recommended\n\n**Common Examples:**\n```javascript\n// Implicit coercion\n'5' + 3        // '53' (number to string)\n'5' - 3        // 2 (string to number)\n'5' == 5       // true (loose equality)\n!!'hello'      // true (string to boolean)\n\n// Explicit coercion\nString(123)    // '123'\nNumber('456')  // 456\nBoolean('')    // false\nparseInt('10px') // 10\n```\n\n**Conversion Rules:**\n- **To String**: Most values become their string representation\n- **To Number**: Strings with numbers become numbers, others become NaN\n- **To Boolean**: Falsy values (`0`, `''`, `null`, `undefined`, `NaN`, `false`) become `false`\n\n**Best Practices:**\n- Use explicit conversion for clarity\n- Use strict equality (`===`) instead of loose equality (`==`)\n- Be aware of implicit coercion rules\n- Test edge cases thoroughly"
  },
  {
    "main-topic": "Javascript",
    "topic": "Definition",
    "object": "Why is 'this' operator inconsistent in JavaScript?",
    "answer": "The **'this'** operator in JavaScript can be inconsistent because:\n\n**Context-Dependent Binding:**\n- Value determined by **how** the function is called, not **where** it's declared\n- Same function can have different `this` values in different calling contexts\n\n**Multiple Binding Rules:**\n1. **Global context**: `this` refers to global object (window in browsers)\n2. **Object method**: `this` refers to the object\n3. **Constructor**: `this` refers to new instance\n4. **Event handler**: `this` refers to the element\n5. **Arrow functions**: `this` is lexically inherited\n\n**Examples of Inconsistency:**\n```javascript\nconst obj = {\n  name: 'Object',\n  regularMethod: function() {\n    console.log(this.name); // 'Object'\n    \n    setTimeout(function() {\n      console.log(this.name); // undefined (global context)\n    }, 100);\n  },\n  arrowMethod: () => {\n    console.log(this.name); // undefined (lexical this)\n  }\n};\n```\n\n**Dynamic Nature:**\n- `call()`, `apply()`, and `bind()` can change `this` value\n- Event listeners assign `this` to the element\n- Strict mode affects `this` behavior\n\n**Solutions:**\n- Use arrow functions for lexical `this`\n- Use `bind()` to explicitly set `this`\n- Store `this` in a variable (`const self = this`)\n- Use explicit context passing"
  }
]
